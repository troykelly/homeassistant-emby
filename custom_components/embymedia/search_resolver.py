"""Utility to resolve Home Assistant *play_media* payloads to concrete Emby items.

The Home Assistant service signature is::

    media_player.play_media(entity_id=..., media_type=..., media_id=...)

Where ``media_type`` corresponds to :pyclass:`homeassistant.components.media_player.MediaType`
constants and ``media_id`` is either a *content id* (URI/URL) generated by the
frontend or a free-form string coming from voice assistants, automations or the
developer tools.

This resolver translates the tuple into an Emby ``ItemId`` - the primary key we
need to pass to ``/Sessions/{id}/Playing`` in order to start playback.

The implementation purposefully keeps the logic *very* conservative: it only
performs one API round-trip (``/Items?SearchTerm=``) and returns the **first**
match.  More advanced strategies (fuzzy scoring, season/episode parsing,
playlists, etc.) will be added in follow-up iterations once a realistic set of
test-cases has been collected.
"""

from __future__ import annotations

import logging
import re
from typing import Any, Dict, List, Sequence

# Importing *MediaType* directly from the root module triggers a
# *reportPrivateImportUsage* warning in Pyright because the symbol is formally
# re-exported from the public *const* sub-module.  Import from the canonical
# location to keep static analysis clean.

from homeassistant.components.media_player.const import MediaType

from .api import EmbyAPI, EmbyApiError

__all__ = [
    "MediaLookupError",
    "resolve_media_item",
]


_LOGGER = logging.getLogger(__name__)


class MediaLookupError(RuntimeError):
    """Raised when the resolver cannot uniquely map the payload to an item."""


# ---------------------------------------------------------------------------
# Helper - map Home Assistant media types -> Emby item types
# ---------------------------------------------------------------------------

_MEDIA_TYPE_MAP: Dict[str, Sequence[str]] = {
    MediaType.MOVIE: ("Movie",),
    MediaType.TVSHOW: ("Series", "Episode"),
    MediaType.EPISODE: ("Episode",),
    MediaType.SEASON: ("Season",),
    MediaType.MUSIC: ("Audio", "MusicAlbum", "MusicArtist", "MusicVideo"),
    MediaType.PLAYLIST: ("Playlist",),
    MediaType.CHANNEL: ("TvChannel",),
    MediaType.VIDEO: ("Video",),
}

# A simple regex used to detect the common "S02E05" episode notation.  We keep
# it *loose* so that variations like "s2e5" or "S2E05" still match.
_EP_RE = re.compile(r"[sS](\d{1,2})[eE](\d{1,2})")


# ---------------------------------------------------------------------------
# Public resolver entry-point
# ---------------------------------------------------------------------------


async def resolve_media_item(
    api: EmbyAPI,
    *,
    media_type: str | None,
    media_id: str,
    user_id: str | None = None,
) -> Dict[str, Any]:
    """Return a concrete Emby item for *play_media* arguments.

    Parameters
    ----------
    api
        Initialised :class:`~components.emby.api.EmbyAPI` instance.
    media_type / media_id
        Values forwarded by Home Assistant. ``media_type`` may be *None* when
        voice assistants omit the field - the resolver falls back to a broad
        search in that case.
    user_id
        Optional Emby user id - used to respect parental control / views.

    Returns
    -------
    dict
        The full Emby item (``BaseItemDto``) obtained via ``/Items``.
    """

    # ---------------------------------------------------------------------
    # Fast-path - caller already passed a raw Emby item id (uuid/int).
    # ---------------------------------------------------------------------

    if _looks_like_item_id(media_id):
        item = await api.get_item(media_id)
        if item is not None:
            return item
        _LOGGER.debug("Value %s looked like an ItemId but was not found", media_id)

    # ---------------------------------------------------------------------
    # Heuristic search using the `/Items` filter API.
    # ---------------------------------------------------------------------

    search_types: List[str] | None = None
    if media_type and media_type in _MEDIA_TYPE_MAP:
        search_types = list(_MEDIA_TYPE_MAP[media_type])

    # ------------------------------------------------------------------
    # Fast-path for **Live TV channels** (GitHub issue #202)
    # ------------------------------------------------------------------
    # The Emby REST API does *not* expose `TvChannel` objects through the
    # generic `/Items/{id}` endpoint – a call returns HTTP 404 even though the
    # identifier **is** valid and can be used for playback via
    # `/Sessions/{id}/Playing`.  Attempting to validate the id through
    # :pymeth:`EmbyAPI.get_item` therefore yields *None* which ultimately
    # bubbles up as "No matching items found" in Home Assistant.
    #
    # To keep the resolver lightweight and avoid additional network
    # round-trips we short-circuit the lookup when the caller explicitly
    # requests a *channel* **and** the provided value already resembles an
    # Emby identifier.  Returning a minimal placeholder dictionary is
    # sufficient because the MediaPlayer service only needs the *Id* field
    # for the subsequent *play* command – metadata such as *Name* is not used
    # during playback.
    #
    # The heuristic mirrors the existing `_looks_like_item_id()` helper which
    # intentionally errs on the side of *false negatives*; in those cases we
    # gracefully fall back to the full-text search logic further below which
    # remains unchanged.
    # ------------------------------------------------------------------

    # Support Home Assistant's *content-id* URI scheme – the frontend encodes
    # native Emby identifiers as ``emby://<id>``.  Strip the prefix so the
    # remaining string can be evaluated by the heuristics below.  We purpose
    # intentionally keep the *scheme* very narrow (exact "emby://") so we do
    # not accidentally consume http/https URLs which must be resolved via the
    # generic `/Items` search.
    if media_id.startswith("emby://"):
        media_id = media_id[len("emby://") :]

    if media_type == MediaType.CHANNEL and _looks_like_item_id(media_id):
        return {"Id": media_id, "Type": "TvChannel"}

    # Special-case: user passed an episode shorthand like "S02E05" - include
    # Episode in the type filter unconditionally so that a series search does
    # not hide direct episode hits.
    if _EP_RE.match(media_id) and search_types:
        if "Episode" not in search_types:
            search_types.append("Episode")

    try:
        results = await api.search(
            search_term=media_id,
            item_types=search_types,
            user_id=user_id,
            limit=5,
        )
    except EmbyApiError as exc:
        raise MediaLookupError("Emby API error during search") from exc

    if not results:
        raise MediaLookupError("No matching items found")

    # At this stage we simply return the *first* match - a future enhancement
    # can pick the highest rated item or ask the user to disambiguate.
    return results[0]


# ---------------------------------------------------------------------------
# Small helpers
# ---------------------------------------------------------------------------


_HEX_RE = re.compile(r"^[0-9a-fA-F]{8,}$")  # heuristic - numeric ids are also accepted


def _looks_like_item_id(value: str) -> bool:  # noqa: D401 - simple helper
    """Return *True* when *value* resembles an Emby ItemId.

    The function errs on the side of **false negatives** - we only claim "looks
    like" when the string is clearly an ID (hex or decimal digits, possibly a
    UUID without dashes).  This avoids accidentally short-circuiting legitimate
    title searches like "1917" or "007".
    """

    # Hex uuid without dashes or a long decimal
    if _HEX_RE.match(value) or value.isdigit():
        # Emby numeric identifiers for *TvChannel* can be as short as 6 digits.
        # Keep a slightly lower guard to avoid matching everyday numbers like
        # *007* while still recognising legitimate ids used by the Live TV
        # feature.
        return len(value) >= 6

    # UUID with dashes - 8-4-4-4-12
    if len(value) == 36 and value.count("-") == 4:
        return True

    return False
